# HANDOFF: QuestionForge Pipeline v2.1 Implementation
**Date:** 2026-01-25  
**From:** Chat Session - Architecture Review  
**To:** Claude Code / Desktop  
**Priority:** HIGH - Ready to implement

---

## Executive Summary

RFC-013 is COMPLETE and approved. QuestionForge Pipeline v2.1 architecture is ready for implementation. This handoff provides everything needed to start building.

**Immediate Goal:** Get Niklas's 40 ARTI1000X questions from M3 output ‚Üí QTI package for Canvas

**Status:**
- ‚úÖ RFC-013 documented and finalized
- ‚úÖ All architectural decisions made
- ‚úÖ Step 2 Validator exists (RFC-012)
- ‚úÖ Step 4 Export exists
- ‚ùå Step 3 Auto-fix needs implementation (PRIORITY)
- ‚ùå Routing Layer needs implementation
- ‚ùå Step 1 MCP tools (can wait - future)

---

## Key Documents

**Primary Reference:**
- `/Users/niklaskarlsson/AIED_EdTech_projects/QuestionForge/docs/rfcs/RFC-013-Questionforge pipeline architecture v2.md`

**Related:**
- RFC-012: Validator (already implemented)
- RFC-001: Logging infrastructure

---

## Critical Architectural Decisions (From RFC-013)

### 1. Error Classification (3-Tier System)

**MECHANICAL** ‚Üí Step 3 (Auto-fix):
- Missing separators (---)
- Syntax normalization
- Format corrections
- **Quantity doesn't matter** (1 or 100 errors = same approach)
- Pattern-based, no human judgment needed

**STRUCTURAL DECISIONS** ‚Üí Step 1 (Teacher):
- Question naming/identifiers (when ambiguous)
- Structural ambiguities
- Requires human judgment

**PEDAGOGICAL** ‚Üí M5 (Content creation):
- Missing question types
- Missing correct answers
- Missing feedback
- Teacher must provide content

### 2. Pipeline Flow

```
Step 2: Validate questions.md
  ‚Üì
  Creates: issues.json
  ‚Üì
Routing Layer:
  ‚îú‚îÄ Pedagogical? ‚Üí M5 (EXIT)
  ‚îú‚îÄ Structural? ‚Üí Step 1 (EXIT)  
  ‚îî‚îÄ Mechanical? ‚Üí Step 3
       ‚Üì
Step 3 Iteration (MAX 10 rounds):
  Round 1: Pick 1 issue ‚Üí Fix in questions.md ‚Üí Save
  Step 2: Validate ‚Üí NEW issues.json
  Round 2: Pick 1 issue ‚Üí Fix in questions.md ‚Üí Save
  Step 2: Validate ‚Üí NEW issues.json
  ...
  ‚Üì
  ‚îú‚îÄ Valid? ‚Üí Step 4 Export ‚úÖ
  ‚îú‚îÄ Pedagogical/Structural found? ‚Üí Route (EXIT)
  ‚îî‚îÄ Max rounds? ‚Üí ERROR REPORT
```

**Key Points:**
- Step 3 fixes **1 issue per round**
- Each round: fix ‚Üí save ‚Üí validate ‚Üí check routing
- Files: `issues.json` (input) + `questions.md` (edit in-place)
- Step 3 NEVER routes - routing happens externally

### 3. Pattern Learning

**Phase 1-3 (CURRENT):**
- Separate pattern systems
- `step1_patterns.json` (Step 1 only)
- `step3_fix_rules.json` (Step 3 only)
- No cross-communication

**Phase 4-5 (FUTURE):**
- Cross-learning between components
- Can wait for later implementation

---

## Implementation Priority

### PHASE 0: Test Current State (30 min) - DO THIS FIRST

**Goal:** Understand what works and what's needed

**Action:**
```bash
# 1. Find Niklas's 40 ARTI1000X questions
# Location: Ask Niklas or search for latest M3 output

# 2. Run Step 2 validator
python -m qf_pipeline.step2_validate \
  --input /path/to/arti1000x_questions.md \
  --output issues.json

# 3. Analyze issues.json
cat issues.json | jq '.'

# 4. Report:
# - How many errors total?
# - Breakdown: mechanical / structural / pedagogical
# - Most common error types
```

**Expected Result:**
- issues.json with categorized errors
- Understanding of what Step 3 needs to fix

---

### PHASE 1: Routing Layer (2-3 hours)

**Goal:** Route errors to correct component

**File:** `qf_pipeline/routing.py`

**Functionality:**
```python
def route_errors(issues_json_path: str) -> dict:
    """
    Read issues.json from Step 2
    Determine where to route based on error types
    
    Returns:
        {
            "route_to": "M5" | "Step1" | "Step3" | "Step4",
            "reason": str,
            "errors": list
        }
    """
    issues = read_json(issues_json_path)
    
    # Priority 1: Pedagogical (blocking)
    if issues.get('pedagogical'):
        return {
            "route_to": "M5",
            "reason": "Missing essential content - teacher must provide",
            "errors": issues['pedagogical']
        }
    
    # Priority 2: Structural (requires judgment)
    if issues.get('structural'):
        return {
            "route_to": "Step1",
            "reason": "Human judgment required",
            "errors": issues['structural']
        }
    
    # Priority 3: Mechanical (auto-fixable)
    if issues.get('mechanical'):
        return {
            "route_to": "Step3",
            "reason": "Pattern-based auto-fix",
            "errors": issues['mechanical']
        }
    
    # No errors
    return {
        "route_to": "Step4",
        "reason": "Validation passed - ready for export"
    }
```

**Test:**
```bash
python -m qf_pipeline.routing --input issues.json
# Should print routing decision
```

---

### PHASE 2: Step 3 Auto-Fix Core (1-2 days) - CRITICAL

**Goal:** Fix mechanical errors one at a time

**File:** `qf_pipeline/step3_autofix.py`

**Architecture:**

```python
class Step3AutoFix:
    """
    Auto-fix mechanical errors through iteration
    """
    
    def __init__(self, questions_file: str, max_rounds: int = 10):
        self.questions_file = questions_file
        self.max_rounds = max_rounds
        self.fix_rules = self.load_fix_rules()
    
    def run_iteration_loop(self) -> dict:
        """
        Main iteration loop
        Returns final status
        """
        round = 0
        
        while round < self.max_rounds:
            # Step 2: Validate
            validation_result = self.validate()
            issues = validation_result['issues']
            
            # Check routing
            if issues.get('pedagogical'):
                return self.route_to_m5(issues['pedagogical'])
            
            if issues.get('structural'):
                return self.route_to_step1(issues['structural'])
            
            if not issues.get('mechanical'):
                return self.route_to_step4()  # Success!
            
            # Pick 1 mechanical issue
            issue = self.pick_one_issue(issues['mechanical'])
            
            # Find fix rule
            fix_rule = self.match_fix_rule(issue)
            
            if not fix_rule:
                self.log_unfixable(issue)
                round += 1
                continue
            
            # Apply fix
            self.apply_fix(issue, fix_rule)
            self.save_questions_file()
            
            # Log transformation
            self.log_transformation(issue, fix_rule, round)
            
            round += 1
        
        # Max rounds reached
        return {
            "status": "max_rounds_reached",
            "rounds": self.max_rounds,
            "remaining_errors": self.validate()['issues']
        }
    
    def pick_one_issue(self, mechanical_issues: list) -> dict:
        """
        Pick 1 mechanical issue to fix this round
        Priority: highest confidence fix rule first
        """
        for issue in mechanical_issues:
            rule = self.match_fix_rule(issue)
            if rule and rule['confidence'] > 0.8:
                return issue
        
        # No high-confidence rule, pick first
        return mechanical_issues[0]
    
    def match_fix_rule(self, issue: dict) -> dict | None:
        """
        Find fix rule for this issue type
        Returns None if no rule found
        """
        error_type = issue['error_type']
        
        for rule in self.fix_rules:
            if rule['error_type'] == error_type:
                return rule
        
        return None
    
    def apply_fix(self, issue: dict, fix_rule: dict):
        """
        Apply fix to questions.md file
        Edit in-place
        """
        # Implementation depends on error type
        # See fix implementations below
        pass
```

**Fix Implementations (Start with these):**

```python
def fix_missing_separator(self, issue: dict):
    """
    Fix: Missing --- separator
    
    Issue format:
    {
        "error_type": "missing_separator",
        "location": "after_question",
        "question_id": "Q005",
        "line_number": 112
    }
    """
    content = self.read_questions_file()
    lines = content.split('\n')
    
    # Insert --- at specified line
    insert_at = issue['line_number']
    lines.insert(insert_at, '---')
    
    # Save
    self.write_questions_file('\n'.join(lines))
    
    return {"status": "fixed", "fix_type": "insert_separator"}

def fix_syntax_normalization(self, issue: dict):
    """
    Fix: Syntax like 'type:' ‚Üí '^type'
    """
    content = self.read_questions_file()
    
    # Find incorrect syntax
    old_pattern = issue['old_syntax']  # e.g., "type: multiple_choice"
    new_pattern = issue['new_syntax']  # e.g., "^type multiple_choice"
    
    # Replace
    content = content.replace(old_pattern, new_pattern)
    
    self.write_questions_file(content)
    
    return {"status": "fixed", "fix_type": "syntax_normalization"}
```

**Fix Rules Database:** `logs/step3_fix_rules.json`

```json
{
  "rules": [
    {
      "rule_id": "STEP3_001",
      "error_type": "missing_separator",
      "description": "Insert --- separator between questions",
      "fix_function": "fix_missing_separator",
      "confidence": 0.95,
      "success_count": 0,
      "applied_count": 0
    },
    {
      "rule_id": "STEP3_002",
      "error_type": "syntax_normalization",
      "description": "Convert 'type:' to '^type'",
      "fix_function": "fix_syntax_normalization",
      "confidence": 0.9,
      "success_count": 0,
      "applied_count": 0
    }
  ]
}
```

**Logging:** `logs/step3_iterations.jsonl`

```jsonl
{"timestamp": "2026-01-25T16:00:00Z", "round": 1, "issue": {...}, "fix_rule": "STEP3_001", "status": "success"}
{"timestamp": "2026-01-25T16:00:05Z", "round": 2, "issue": {...}, "fix_rule": "STEP3_002", "status": "success"}
```

**Test:**
```bash
python -m qf_pipeline.step3_autofix \
  --input questions.md \
  --output questions_fixed.md \
  --max-rounds 10
```

---

### PHASE 3: Full Pipeline Script (1 day)

**Goal:** Run entire pipeline end-to-end

**File:** `qf_pipeline/run_pipeline.py`

```python
#!/usr/bin/env python3
"""
QuestionForge Pipeline v2.1
Complete pipeline execution
"""

def run_pipeline(input_file: str, output_file: str):
    """
    Run complete pipeline:
    Step 2 ‚Üí Routing ‚Üí Step 3 ‚Üí Step 4
    """
    
    print("QuestionForge Pipeline v2.1")
    print("=" * 50)
    
    # Step 2: Validate
    print("\n[Step 2] Validating...")
    issues = step2_validate(input_file)
    
    if not issues:
        print("‚úÖ No issues found!")
        return export_qti(input_file, output_file)
    
    # Routing
    print("\n[Routing] Analyzing errors...")
    route = route_errors(issues)
    
    if route['route_to'] == 'M5':
        print("‚ùå PEDAGOGICAL errors found - M5 required")
        print(f"   Errors: {len(route['errors'])}")
        return {"status": "needs_m5", "errors": route['errors']}
    
    if route['route_to'] == 'Step1':
        print("‚ùå STRUCTURAL errors found - Step 1 required")
        print(f"   Errors: {len(route['errors'])}")
        return {"status": "needs_step1", "errors": route['errors']}
    
    # Step 3: Auto-fix
    print("\n[Step 3] Auto-fixing mechanical errors...")
    print(f"   Found: {len(route['errors'])} mechanical errors")
    
    result = step3_autofix(input_file, max_rounds=10)
    
    if result['status'] == 'success':
        print(f"‚úÖ Fixed in {result['rounds']} rounds!")
        return export_qti(input_file, output_file)
    
    if result['status'] == 'max_rounds_reached':
        print(f"‚ö†Ô∏è  Max rounds reached ({result['rounds']})")
        print(f"   Remaining errors: {len(result['remaining_errors'])}")
        return result
    
    # Routed to another component
    if result['status'] == 'needs_m5':
        print("‚ùå New pedagogical errors found")
        return result
    
    if result['status'] == 'needs_step1':
        print("‚ùå New structural errors found")
        return result

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 3:
        print("Usage: python -m qf_pipeline.run_pipeline INPUT OUTPUT")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    result = run_pipeline(input_file, output_file)
    
    if result.get('status') == 'success':
        print(f"\n‚úÖ SUCCESS! QTI package: {output_file}")
        sys.exit(0)
    else:
        print(f"\n‚ùå FAILED: {result}")
        sys.exit(1)
```

**Usage:**
```bash
python -m qf_pipeline.run_pipeline \
  arti1000x_40_questions.md \
  arti1000x_qti_package.zip
```

---

## Files to Create

### New Files:
```
qf_pipeline/
‚îú‚îÄ‚îÄ routing.py              (NEW - PHASE 1)
‚îú‚îÄ‚îÄ step3_autofix.py        (NEW - PHASE 2)
‚îî‚îÄ‚îÄ run_pipeline.py         (NEW - PHASE 3)

logs/
‚îî‚îÄ‚îÄ step3_fix_rules.json    (NEW - Initial rules)
```

### Existing Files (use these):
```
qf_pipeline/
‚îú‚îÄ‚îÄ step2_validate.py       (EXISTS - RFC-012)
‚îú‚îÄ‚îÄ step4_export.py         (EXISTS)
‚îî‚îÄ‚îÄ markdown_parser.py      (EXISTS - RFC-012)
```

---

## Testing Strategy

### Test Data:
Use Niklas's 40 ARTI1000X questions as primary test case

### Test Progression:

**Test 1: Validation**
```bash
python -m qf_pipeline.step2_validate \
  --input test_questions.md \
  --output issues.json

# Expected: issues.json with categorized errors
```

**Test 2: Routing**
```bash
python -m qf_pipeline.routing --input issues.json

# Expected: Route decision (M5/Step1/Step3/Step4)
```

**Test 3: Single Fix**
```bash
python -m qf_pipeline.step3_autofix \
  --input test_questions.md \
  --max-rounds 1

# Expected: 1 error fixed, file saved
```

**Test 4: Full Iteration**
```bash
python -m qf_pipeline.step3_autofix \
  --input test_questions.md \
  --max-rounds 10

# Expected: All mechanical errors fixed OR max rounds
```

**Test 5: Complete Pipeline**
```bash
python -m qf_pipeline.run_pipeline \
  test_questions.md \
  output.zip

# Expected: Valid QTI package OR clear error report
```

---

## Error Handling

### Expected Errors:

**1. Unfixable mechanical error:**
- Log to `step3_iterations.jsonl`
- Continue to next issue
- Report at end if max rounds reached

**2. New pedagogical/structural errors appear:**
- Route back to M5/Step1
- Exit Step 3 loop
- Clear error message

**3. File I/O errors:**
- Proper error messages
- Don't corrupt questions.md
- Create backups before edits

---

## Success Criteria

### PHASE 0:
‚úÖ Step 2 validator runs successfully  
‚úÖ issues.json created with correct format  
‚úÖ Understand error breakdown for ARTI1000X questions

### PHASE 1:
‚úÖ Routing layer correctly categorizes all error types  
‚úÖ Routes to correct component  
‚úÖ Clear output messages

### PHASE 2:
‚úÖ Step 3 can fix at least 1 error type (missing separator)  
‚úÖ Iteration loop works (10 rounds max)  
‚úÖ File saved after each fix  
‚úÖ Logging to step3_iterations.jsonl

### PHASE 3:
‚úÖ Full pipeline runs end-to-end  
‚úÖ ARTI1000X questions ‚Üí QTI package  
‚úÖ Clear error reporting for failures

---

## Future Work (Can Wait)

### Step 1 MCP Tools (1-2 weeks):
- Interactive guided build
- Teacher approval gates
- Progress tracking
- Question-by-question review

**Note:** This can wait! Focus on getting Step 3 working first.

### M5 Quality Assurance:
- Only needed for new question generation
- ARTI1000X questions already exist
- Can be implemented later

### Pattern Learning Enhancements:
- Cross-learning between Step 1 and Step 3
- Pattern merging
- Confidence scoring improvements

---

## Questions for Niklas

**Before starting implementation:**

1. **Where are the 40 ARTI1000X questions?**
   - File path?
   - Format (raw M3 output or processed)?

2. **Which repo/branch to work in?**
   - QuestionForge main?
   - New branch?

3. **Can you run PHASE 0 test now?**
   - Validate questions
   - Share issues.json output

4. **Any deadline for QTI package?**
   - When do you need it?

---

## Critical Notes

1. **Step 3 fixes 1 issue at a time** - This is intentional for learning and safety

2. **Routing happens OUTSIDE Step 3** - Step 3 never routes itself

3. **issues.json is recreated after each fix** - Always read fresh from Step 2

4. **questions.md is edited in-place** - Make backups!

5. **Max 10 rounds** - Prevents infinite loops

6. **Pattern learning is separate for now** - Phase 1-3 implementation

---

## Next Steps

**For Claude Code/Desktop:**

1. Read RFC-013 completely
2. Run PHASE 0 test with Niklas's questions
3. Analyze issues.json output
4. Implement PHASE 1 (Routing Layer)
5. Implement PHASE 2 (Step 3 core)
6. Test with real data
7. Implement PHASE 3 (Full pipeline)
8. Get QTI package for Niklas! üéØ

---

**END OF HANDOFF**

Ready to build! üöÄ